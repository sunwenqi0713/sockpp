/**
 * @file SocketSelector.cpp
 * @brief Socket multiplexer implementation.
 *
 * sockpp - Simple C++ Socket Library
 */

#include <sockpp/Socket.h>
#include <sockpp/SocketSelector.h>

#include <iostream>
#include <utility>

#include "SocketImpl.h"

#ifdef _MSC_VER
#pragma warning(disable : 4127)  // "conditional expression is constant" generated by the FD_SET macro
#endif

namespace sockpp {

struct SocketSelector::SocketSelectorImpl {
  fd_set allSockets;    ///< Set containing all the sockets handles.
  fd_set socketsReady;  ///< Set containing handles of the sockets that are ready.
  int maxSocket{};      ///< Maximum socket handle.
  int socketCount{};    ///< Number of socket handles.
};

SocketSelector::SocketSelector() : m_impl(std::make_unique<SocketSelectorImpl>()) { clear(); }

SocketSelector::~SocketSelector() = default;

SocketSelector::SocketSelector(const SocketSelector& copy)
    : m_impl(std::make_unique<SocketSelectorImpl>(*copy.m_impl)) {}

SocketSelector& SocketSelector::operator=(const SocketSelector& right) {
  if (this != &right) {
    *m_impl = *right.m_impl;
  }

  return *this;
}

SocketSelector::SocketSelector(SocketSelector&&) noexcept = default;

SocketSelector& SocketSelector::operator=(SocketSelector&&) noexcept = default;

void SocketSelector::add(Socket& socket) {
  const SocketHandle handle = socket.getNativeHandle();

  if (handle != detail::SocketImpl::invalidSocket()) {
#if defined(SOCKPP_SYSTEM_WINDOWS)

    if (m_impl->socketCount >= FD_SETSIZE) {
      std::cerr << "The socket can't be added to the selector because the "
                << "selector is full. This is a limitation of your operating "
                << "system's FD_SETSIZE setting." << std::endl;
      return;
    }

    if (FD_ISSET(handle, &m_impl->allSockets)) {
      return;
    }

    m_impl->socketCount++;

#else

    if (handle >= FD_SETSIZE) {
      std::cerr << "The socket can't be added to the selector because its "
                << "ID is too high. This is a limitation of your operating "
                << "system's FD_SETSIZE setting." << std::endl;
      return;
    }

    // SocketHandle is an int in POSIX.
    m_impl->maxSocket = std::max(m_impl->maxSocket, handle);

#endif

    FD_SET(handle, &m_impl->allSockets);
  }
}

void SocketSelector::remove(Socket& socket) {
  const SocketHandle handle = socket.getNativeHandle();

  if (handle != detail::SocketImpl::invalidSocket()) {
#if defined(SOCKPP_SYSTEM_WINDOWS)

    if (!FD_ISSET(handle, &m_impl->allSockets)) {
      return;
    }

    m_impl->socketCount--;

#else

    if (handle >= FD_SETSIZE) {
      return;
    }

#endif

    FD_CLR(handle, &m_impl->allSockets);
    FD_CLR(handle, &m_impl->socketsReady);
  }
}

void SocketSelector::clear() {
  FD_ZERO(&m_impl->allSockets);
  FD_ZERO(&m_impl->socketsReady);

  m_impl->maxSocket = 0;
  m_impl->socketCount = 0;
}

bool SocketSelector::wait(std::chrono::milliseconds timeout) {
  // Setup the timeout.
  timeval time{};
  time.tv_sec = static_cast<long>(timeout.count() / 1000);
  time.tv_usec = static_cast<int>((timeout.count() % 1000) * 1000);

  // Initialize the set that will contain the sockets that are ready.
  m_impl->socketsReady = m_impl->allSockets;

  // Wait until one of the sockets is ready for reading, or timeout is reached.
  // The first parameter is ignored on Windows.
  const int count = select(m_impl->maxSocket + 1, &m_impl->socketsReady, nullptr, nullptr,
                           timeout != std::chrono::milliseconds::zero() ? &time : nullptr);

  return count > 0;
}

bool SocketSelector::isReady(Socket& socket) const {
  const SocketHandle handle = socket.getNativeHandle();

  if (handle != detail::SocketImpl::invalidSocket()) {
#if !defined(SOCKPP_SYSTEM_WINDOWS)
    if (handle >= FD_SETSIZE) {
      return false;
    }
#endif

    return FD_ISSET(handle, &m_impl->socketsReady) != 0;
  }

  return false;
}

}  // namespace sockpp
